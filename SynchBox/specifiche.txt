SyncBox Client+Server
Bertrone Matteo
06/10/2015

DB Sqlite sul server

USERS:
uid int pk
user string
md5 string

/*tiene traccia delle sessioni di sincronizzazione in maniera incrementale! */
/*ciò vuol dire che l'atomicità viene spostata sul singolo add, update, delete mentre se una sessione di sincronizzazione non viene terminata
completamente, vengono comunque mantenuti i file salvati fino a quel punto*/
SYNCH_SESSION:
uid*
synchsessionid*
timestamp
n_updated
n_deleted
n_added
//succesfull

SNAPSHOT: (mantiene i puntatori ai file presenti nell'ultimo snapshot. Se aggiorno un file cancello rev precendente e inserisco quella nuova)
uid* int INDEX
fid* int
rev int
syncid int (numero crescente che tiene traccia dell'ultima sincronizzazione con modifiche.)
//se seleziono il max syncid di un uid e lo comparo con quello del client so se devo ripetere la sync o meno

HISTORY: (mantiene la history dei file) - INDEX (UID,FID,REV) ??
uid* int INDEX
fid* int INDEX
rev* int
synchsessionid
filename string			(HA SENSO TENERLI SEPARATI?)
folder string
timestamp datetime
md5 string
deleted? boolean


FILES_DUMP:
uid* int
fid* int
rev* int
byte_array filedump



PROTOCOLLO:

//LOGIN LOGOUT REGISTER


//DATA SYNC

SERVER--------------------------CLIENT
			
			ListRequest(listReqType[Last, All /*, DateInterval, Filename */])
<<-----------------------------------
(Richiede la versione più aggiornata sul server)


			ListResponse(List<FileListItem>)
            int fid;int rev;string filename;string folder;DateTime datetime;string md5;Boolean deleted;
--------------------------------->>
(manda una lista con lo snapshot)



		GetList(int n, List<FileToGet[int fid,int rev]>)
<<--------------------------------

		GetResponse(FileToGet, Byte[] filedump)
		MANDA UN SOLO FILE
------------------------------->>

//////////INIZIO SESSIONE

		BeginSession(synchsessionid = -1)
<<-------------------------
		BeginSession(syncsessionid = X)
-------------------------->>

il server salva in una variabile di stato la synchsessionid corrente e lo usa per tutte le update, add, delete successive!

//////////FINE SESSIONE

		EndSession(synchsessionid = X, succesfull = null or false)
<<--------------------------------
		EndSession(syncsessionid = X, succesful = true)
--------------------------------->


//////////INSIDE SESSION

		Update(fid,Byte[]fileDump)
<<-------------------------------

		UpdateOk(fid,rev)
------------------------------->>


		Delete(fid) 
<<------------------------------

		DeleteOk(fid,syncid)
------------------------------->>


		Add(filename, folder, fileDump)
<<-----------------------------

		AddOkk(fid, rev, syncid)
------------------------------->>

///CONTROLLO DI SINCRONIZZAZIONE

		GetSynchId(int synchid= -1)
<<-------------------------
		GetSynchId(int synchid= Y)
------------------------->>



sync diventa monitor

idea:
-------------------------------------
client Monitor

il client si accende e richiede l'ultima versione! (se è la prima volta fa anche restore last server version, magari prima chiede conferma)

si salva in locale la struttura che contiene dati server, dati client

timer: 30 secondi

inizio a comparare client e server,
BEGIN SESSION

ADD
DELETE
UPDATE

END SESSION

va avanti così in loop

-------------------------------------
(INTERFACCIA FRIZZATA SE è IN CORSO UNA SYNC)

client Restore (By File, By Last Snapshot @ server, /*OR BY A SPECIFIC SYNCSESSION*/)
(prima di fare restore, faccio un getSyncID se uguali sono sincronizzato con il server!)

fa una list request all al server, e ottine i metadati di tutte le versioni

seleziono un file e posso farne il restore sul fs locale con
GetList (singolo file in lista)


<//TODO 
idee per le interfacce grafiche
due treeview con differenze in blu update rosso deleted verde added nero uguale

binding (chiedere a cisco detto ciccio)
----------------------------------------

SERVER

//TODO
CHiedersi se vale la pensa gestire tutto con eccezioni in dbhelper!!!

